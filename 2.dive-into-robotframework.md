title: PART 2: Dive Into RobotFramework
speaker: Zhang Yu
url: https://github.com/feiyuw/idiomatic-robotframework
transition: cards
files: /css/theme.moon.css

[slide]

# PART 2: Dive Into RobotFramework
## From：Zhang Yu

[slide]

## RobotFramework的开发模式探寻
----
* 基于github {:&.moveIn}
* 工作在master分支上 (但不是直接提交到master)
* 使用github的issue系统来管理需求
* 使用**pull request**来进行code review
* milestone, branch, tag和release

[slide]

## RobotFramework的测试
----
* Unit Testing

        python utest/run_utests.py

* Acceptance Testing

        python atest/run_atests.py python robot

[slide]

## RobotFramework的整体工作流
----
* ![RobotFramework Workflow](/img/robot_workflow.png "RobotFramework Workflow")

[slide]

## RobotFramework的主要模块
----
* robot.run
* robot.model
* robot.parsing
* robot.running
* robot.output
* robot.result
* robot.reporting

[slide]

### robot.run
----
* main class - robot.run.RobotFramework
* 执行接口 - robot.run.run
* 命令行执行接口 - robot.run.run_cli

[slide]

### robot.model
----
* RobotFramework的数据层 {:&.moveIn}
* 大概分为以下几类:
    * 基本类型
    * RobotFramework case的抽象
        * 基本都有一个visit方法
    * 构建上述抽象类的工厂
    * 对抽象类的装饰(如filter)

[slide]

#### 基本类型
----
* robot.modelobject.ModelObject {:&.moveIn}
* robot.itemlist.ItemList

[slide]

#### RobotFramework case的抽象
----
* robot.model.imports {:&.moveIn}
* robot.model.keyword
* robot.model.message
* robot.model.metadata
* robot.model.statistics.Statistics
* robot.model.suitestatistics.SuiteStatistics
* robot.model.tags
* robot.model.tagstatistics.TagStatistics
* robot.model.testcase
* robot.model.testsuite
* robot.model.totalstatistics.TotalStatistics

[slide]

#### 构建上述抽象类的工厂
----
* robot.model.configurer.SuiteConfigurer {:&.moveIn}
* robot.model.statistics.StatisticsBuilder
* robot.model.stats
* robot.model.suitestatistics.SuiteStatisticsBuilder
* robot.model.tagsetter
* robot.model.tagstatistics.TagStatisticsBuilder
* robot.model.totalstatistics.TotalStatisticsBuilder

[slide]

#### 对抽象类的装饰
----
* robot.model.criticality.Criticality {:&.moveIn}
* robot.model.filter
* robot.model.visitor

[slide]

### robot.parsing
----
* case文件或目录的解析模块 {:&.moveIn}
    * htmlreader
    * restreader
    * tsvreader
    * txtreader
* case文件或目录到model的转换 - robot.parsing.model.TestData
    * settings_table
    * testcase_table
    * keyword_table
* 行解析robot.parsing.datarow
* settings表的数据结构robot.parsing.settings

[slide]

### robot.running
----
* TestSuite的工厂类 - robot.running.builder {:&.moveIn}
* 运行时的所有信息 - robot.running.context  (EXECUTION_CONTEXTS)
* 传递给robot的单个suite的运行数据 - robot.running.namespace
* 实际执行suite的class - robot.running.runner
* signal监控 - robot.running.signalhandler
* 一些suite运行时的默认数据 - robot.running.defaults
* 参数处理 - robot.running.arguments
* 超时处理 - robot.running.timeouts
* 运行时的模型抽象
* 一些基本的抽象类型
* 工具类

[slide]

#### robot.running.defaults
----
* TestDefaults {:&.moveIn}
    基于robot.parsing.model.TestData得到的setting_table
* TestValues
    基于robot.parsing.model.TestData得到的testcase_table

[slide]

#### 运行时的模型抽象
----
* robot.running.keywords {:&.moveIn}
* robot.running.model (继承自robot.model)
* robot.running.status
* robot.running.testlibraries
* robot.running.userkeyword

[slide]

#### 一些基本的抽象类型
----
* robot.running.baselibrary {:&.moveIn}
* robot.running.dynamicmethods
* robot.running.handlers

[slide]

#### 工具类
----
* robot.running.importer (与robot.utils.importer存在duplication) {:&.moveIn}
* robot.running.outputcapture
* robot.running.randomizer
* robot.running.runkwregister
* robot.running.usererrorhandler

[slide]

### robot.output
----
运行时的各种输出处理
* TestSuite执行时的output处理 - robot.output.output {:&.moveIn}
* RobotFramework的LOGGER - robot.output.logger
* logging模块相关 - robot.output.pyloggingconf
* 各种logger
    * robot.output.debugfile
    * robot.output.filelogger
    * robot.output.monitor
    * robot.output.xmllogger
* Listener处理 - robot.output.listeners
* library logging API - robot.output.librarylogger

[slide]

### robot.result
----
XML output文件的解析模块
* 从output.xml文件创建Result对象 - ExecutionResult {:&.moveIn}
* Result和CombinedResult
* Result处理
    * Merge多个Result
    * flatten keyword
    * remove keyword
* result阶段的model
    * robot.result.configurer
    * robot.result.keyword
    * robot.result.message
    * robot.result.testcase
    * robot.result.testsuite

[slide]

### robot.reporting
----
* 生成log.html和report.html {:&.moveIn}
    * robot.reporting.resultwriter
* 生成新的output.xml
    * robot.reporting.outputwriter
* js形式的log生成器
    * robot.reporting.jswriter
    * robot.reporting.jsbuildingcontext
    * robot.reporting.jsexecutionresult
    * robot.reporting.jsmodelbuilders

[slide]

## robot model的各个阶段
----
* robot.model {:&.moveIn}
* robot.parsing.model
* robot.running.model
* robot.result._model_ (*)

[slide]

## 你知道执行pybot后RobotFramework都做了些什么吗?
----
* 实例化robot.run.RobotFramework {:&.moveIn}
* 命令行参数解析
* 实例化RobotSettings
* 设置LOGGER
* 生成TestSuite
* 执行TestSuite
* 写入log和report
* 判断测试结果
* 结束进程
[note]
* 写入log和report为optional步骤
* 如果有keyword产生的子进程无法结束, 则pybot无法结束
[/note]

[slide]

### 相关代码robot.run.RobotFramework
----
```python
class RobotFramework(Application):

    def __init__(self):
        Application.__init__(self, USAGE, arg_limits=(1,),
                             env_options='ROBOT_OPTIONS', logger=LOGGER)

    def main(self, datasources, **options):
        settings = RobotSettings(options)
        LOGGER.register_console_logger(**settings.console_logger_config)
        LOGGER.info('Settings:\n%s' % unicode(settings))
        suite = TestSuiteBuilder(settings['SuiteNames'],
                                 settings['WarnOnSkipped'],
                                 settings['RunEmptySuite']).build(*datasources)
        suite.configure(**settings.suite_config)
        result = suite.run(settings)
        LOGGER.info("Tests execution ended. Statistics:\n%s"
                    % result.suite.stat_message)
        if settings.log or settings.report or settings.xunit:
            writer = ResultWriter(settings.output if settings.log else result)
            writer.write_results(settings.get_rebot_settings())
        return result.return_code
```

[slide]

## 你知道RobotFramework是怎么找到指定的keyword的吗?

* 当前case中的user keyword {:&.moveIn}
* resource文件中定义的user keyword
* library中定义的keyword
* 相关代码
```python
# robot.running.namespace
def _get_implicit_handler(self, name):
    for method in [self._get_handler_from_test_case_file_user_keywords,
                   self._get_handler_from_resource_file_user_keywords,
                   self._get_handler_from_library_keywords]:
        handler = method(name)
        if handler:
            return handler
    return None
```

[slide]

## 你知道RobotFramework是如何导入Library的?

* 将library名字import为class或者module {:&.moveIn}
* 根据不同的library类型生成对应的Library class
* 相关代码
```python
# robot.running.testlibraries
def TestLibrary(name, args=None, variables=None, create_handlers=True):
    with OutputCapturer(library_import=True):
        importer = Importer('test library')
        libcode = importer.import_class_or_module(name)
    libclass = _get_lib_class(libcode)
    lib = libclass(libcode, name, args or [], variables)
    if create_handlers:
        lib.create_handlers()
    return lib
```

[note]
module library的keyword来源
```python
# robot.running.testlibraries
def _get_handler_names(self, instance):
    try:
        return instance.get_keyword_names()
    except AttributeError:
        return instance.getKeywordNames()

# robot.running.namespace
def _get_handler(self, name):
    handler = None
    if not name:
        raise DataError('Keyword name cannot be empty.')
    if not isinstance(name, basestring):
        raise DataError('Keyword name must be a string.')
    if '.' in name:
        handler = self._get_explicit_handler(name)
    if not handler:
        handler = self._get_implicit_handler(name)
    if not handler:
        handler = self._get_bdd_style_handler(name)
    if not handler:
        handler = self._get_x_times_handler(name)
    return handler
```
[/note]

[slide]

## 你知道suite的默认执行顺序是什么吗?
----
* ![suite执行顺序](/img/suite.png "suite执行顺序") {:&.moveIn}
* 相关代码
```python
# robot.parsing.populators.FromDirectoryPopulator
def _list_dir(self, path):
    # os.listdir returns Unicode entries when path is Unicode
    names = os.listdir(unic(path))
    for name in sorted(names, key=unicode.lower):
        # unic needed to handle nfc/nfd normalization on OSX
        yield unic(name), unic(os.path.join(path, name))
```

[slide]

## 你知道suite的随机执行顺序是什么样的吗?
----
* "--randomize"参数可以将suite/case的执行顺序进行随机调整 {:&.moveIn}
```python
class Randomizer(SuiteVisitor):

    def __init__(self, randomize_suites=True, randomize_tests=True, seed=None):
        # ......
        args = (seed,) if seed is not None else ()
        self._shuffle = Random(*args).shuffle

    def start_suite(self, suite):
        # ......
        if self.randomize_suites:
            self._shuffle(suite.suites)
        if self.randomize_tests:
            self._shuffle(suite.tests)
        # ......
```
[note]
效果类似于:
```
In [1]: from random import Random
In [2]: x = Random().shuffle
In [3]: l = range(4)
In [4]: l
Out[4]: [0, 1, 2, 3]
In [5]: x(l)
In [6]: l
Out[6]: [3, 0, 1, 2]
```
[/note]

[slide]

## 你知道Listener是怎么工作的吗?
----
* robot.output.listeners {:&.moveIn}
* 将listeners追加到LOGGER
* 进行LOGGER操作的时候执行listener的对应接口
* robot.output.output.Output

[slide]

## 你知道RobotFramework的Stop Gracefully是怎么实现的吗?
----
* robot.running.model.TestSuite的run方法 {:&.moveIn}
```
with pyloggingconf.robot_handler_enabled(settings.log_level):
    with STOP_SIGNAL_MONITOR:
        IMPORTER.reset()
        init_global_variables(settings)
        output = Output(settings)
        runner = Runner(output, settings)
        self.visit(runner)
    output.close(runner.result)
return runner.result
```
* robot.running.signalhandler
* 通过signal.signal来实现Ctrl+C的监听

[slide]

## 你知道RobotFramework的Test Timeout是怎么做的吗?
----
* 执行时在开始执行test或keyword的时候, 设置Timeout {:&.moveIn}
    * robot.running.model.TestCase
* 以Python2.7 Linux平台为例
    * robot.running.timeouts.timeoutsignaling.Timeout
* 通过signal模块的setitimer和SIGALRM信号来实现

[slide]

## 练习: RobotFramework是怎么写入log的?
